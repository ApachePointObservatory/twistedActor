<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
	<title>TwistedActor Internals</title>
</head>
<body>
<h1><a href="index.html">TwistedActor</a> Internals</h1>

<p>TwistedActor is a set of classes that allow one to write an actor for the Apache Point Observatory 3.5m or SDSS control system. An actor can be a script running in the hub or an Instrument Control Computer (ICC) running elsewhere.

<p>This manual is intended to help people writing actors based on TwistedActor. In addition there is a manul describing the user interface: <a href="index.html">TwistedActor</a>.

<p>TwistedActor is written in Python and Twisted framework for communications and event-based multitasking. Event-based multitasking generally results in simpler code than multithreaded code. However, one must be careful not to take too long while handling a particular event.

<p>TwistedActor is intrinsically asynchronous. Thus, to the extent that the underlying hardware controllers support it, an actor based on TwistedActor can execute multiple commands at the same time. If a new command is received while an old command is executing then the new command will either be accepted (if compatible) or rejected (if not). Note that it will *not* be queued up; this simplifies programming and removes the need for commands to report and clear the queue.

<h2><a name="Basics">Basics</a></h2>

<h3><a name="Commands">Commands</a></h3>

<p>Commands must be in the following format:
<pre>
  [cmdId [msgId]] [cmdBody]]
</pre>
<p>where:
<ul>
    <li>cmdId: command ID assigned by the user (typically the hub); 0 if not found. CmdID is used to tag replies generated by the command. A command ID of 0 is used for unsolicited replies, so users should not use cmdId = 0 if they want to track replies to a command.
    <li>msgId: ignored (it is a vistigial artifact).
    <li>cmdBody: the body of the command, which must not start with an integer.
</ul>

<p>The default parser further subdivides cmdBody as follows:
<pre>
  [cmdVerb [cmdArgs]]
</pre>
<p>where:
<ul>
    <li>cmdVerb: is a string starting with a letter and containing no whitespace. It is lowercased before being saved.
    <li>cmdArgs: everything after cmdVerb and whitespace.
</ul>

<p>However, if you wish a different format for the command body then:
<ul>
    <li>Subclass Command.UserCmd and override parseCmdBody.
    <li>Decide whether your actor should subclass BaseActor or Actor. The latter relies on extracting a cmdVerb from your command and using that to dispatch the command. The former makes no such assumptions.
    <li>Specify your subclass as the UserCmdClass class attribute of your Actor subclass.
</ul>

<h3><a name="Replies">Replies</a></h3>

<p>Replies must be in hub-standard format (reference?) and prefixed with cmdID userID.

<p><b>Warning</b>: Replies that indicate the end of a command (using message code ":" or "f") must be prefixed with the correct cmdID and userID. If you fail to do this the user has no way of knowing the command is finished! (On the other hand, cmdID and userID are not important for messages that indicate status; you may use 0 for either or both if that is more convenient.)

<h2><a name="WritingAnActor"></a>Writing an Actor</h2>

<h3>Write code for devices</h3>

<p>An actor typically controls one or more devices. For example an Instrument Control Computer (ICC) controls an imager and often a filterwheel or slit turret. A hub actor typically controls an ICC or other hardware controller. 

<p>For each device controlled by your actor: write a software representation of this device as a sublcass of TwistedActor.Device or TwistedActor.TCPDevice. This is a very important part of the actor; expect to spend 50-80% of your time on this task.

<p>The device code tends to fall into several categories: code to support executing commands, code to handle replies and code to represent the internal state of the device.

<p>One thing to keep in mind while writing your device code is: which actor commands can the device handle directly? You can specify these using the cmdInfo argument.

<h3>Write code for the actor</h3>

<p>Write one actor as a sublcass of TwistedActor.Actor or TwistedActor.BaseActor. Actor is suitable for the typical actor on the mountain; it contains a command dispatcher that assumes commands consist of a verb and arguments. BaseActor requires you to write your own command dispatcher and thus makes fewer assumptions about the command format.

<p>Both classes are described in more detail below

<h2><a name="BaseActor"></a>The BaseActor class</h2>

<p>BaseActor is a minimalistic actor class. It accepts connections from users, parses commands and has methods that will issue replies to commands. However, it has no command dispatcher and makes few assumptions about the command format.

<p>Command parsing is performed by the UserCmdClass class attribute. The default is Command.UserCmd, which uses a command format describe above under Commands. A user command must contain the following fields (see also Commands above):
<ul>
    <li>userId: the user's ID number (based on which connection the command was received from)
    <li>cmdID: the command ID number; 0 if not found
    <li>cmdBody: the rest of the command after the header; "" if not found
    <li>state: command state (e.g. cmd.Running, cmd.Done or cmd.Failed)
</ul>

<p>In addition, the default Command.UserCmd contains these fields:
<ul>
    <li>cmdVerb: the first word in the command body, lowercased; "" if not found
    <li>cmdArgs: the rest of the command body after the verb and whitespace; "" if not found
</ul>

<p>BaseActor calls dispatchCmd to dispatch the command. However, it does not include an implementation of this method; your subclass must override it. Actor (described below) does includes an implementation of dispatchCmd that you can probably use as is.

<p>BaseActor/Actor methods include:
<ul>
    <li>writeToUsers: write a message to all connected users.
    <li>writeToOneUser: write a message to one particular user.
</ul>

<h2><a name="Actor"></a>The Actor class</h2>

<p>Actor is a subclass of BaseActor. It has many more capabilities and, for most actors, it will be the most suitable class to subclass for your own actor.

<p>Actor contains the list of devices your actor controls and code to execute certain commands called "local commands".

<p>Local commands are commands implemented as methods of your Actor subclass. Each such method must be named cmd_<i>verb</i> where <i>verb</i> is the command verb. The first line of the doc string for that method is the help for that command (as printed by the command "help"). Each method that implements a local command must return True if the command executes in the background; otherwise the command is reported as finished when the cmd_ method ends.

<p>Note that Actor implements several local commands; do not override these unless you are sure you know what you are doing. These include:
<ul>
    <li>help
    <li>connDev/disconnDev: connect or disconnect a device (all devices by default)
    <li><i>dev</i>: send text directly to a device
</ul>

<h3>Command Dispatcher</h3>

<p>Actor executes the UserCmd object as follows:

<ul>
    <li>Check the command by calling checkLocalCmd

    <p>This verifies that the new command is compatible with whatever else is going on at the time. If there are conditions that prevent a command from executing then you should override checkLocalCmd and add code to detect this (though you may put such code into the code for the command itself if you prefer).

    <p>You may also put code in checkLocalCmd to supersede other commands. But that is more likely to be done in the code that executes a particular command.

    <li>Execute the command

    <p>For a local command this is in a method called cmd_<i>verb</i> where <i>verb</i> is the command verb. This code should:
    <ul>
        <li>parse the arguments (if any)
        <li>check for conditions that would prevent it from being executed (though this is usually done in checkLocalCmd)
        <li>check for commands that must be superseded; if any are found then it should start this process and queue the command to be run once the superseding is done.
        <li>if the command is quick:
        <ul>
            <li>execute the command
            <li>set final status of command to "done" or "failed" as appropriate
        </ul>
        <li>if the command is slow:
        <ul>
            <li>start executing the command
            <li>use code placed elsewhere (often in a state callback for a device) to check the status of the command
        </ul>
        <li>when the command is done then some code somewhere must set final status of command to "done" or "failed"
    </ul>
</ul>

<p>To report a UserCmd as finished call cmd.setState("done") or cmd.setState("failed") as appropriate (note that you can provide an explanatory message at the same time; this is highly recommended if the command fails). The Actor keeps track of the state of each UserCmd and will report the command as finished and then delete the command.

<p>In addition whenever you call newCmd on a device it creates a DevCmd which is very similar to a UserCmd but with slightly different information. It is possible to tie a UserCmd to a DevCmd such that the state of the former tracks the state of the latter. This is especially useful when a user command can be directly handled by a device (perhaps after some initial massaging).

<p>Note that you will probably have to provide a device callback to track each DevCmd and delete it when it is finished (or has timed out).

</body>
</html>
