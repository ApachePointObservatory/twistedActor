<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
	<title>Writing an Actor Using twistedActor</title>
</head>
<body>
<h1>Writing an Actor Using <a href="index.html">twistedActor</a></h1>

<p>This manual describes the details of writing an actor based on twistedActor.

<p>The general issue of writing an actor (such as an instrument control computer) is described in <a href="http://www.apo.nmsu.edu/35m_operations/ICCDesign">Instrument Control Computer Design</a>. Please make sure you understand this material before proceeding.

<p>twistedActor is written in Python and uses Twisted framework for communications and event-based multitasking. Event-based multitasking generally results in simpler code than multithreaded code. However, one must be careful not to take too long while handling a particular event.

<p>twistedActor is intrinsically asynchronous. Thus, to the extent that the underlying hardware controllers support it, an actor based on twistedActor can execute multiple commands at the same time. If a new command is received while an old command is executing then the new command will either be accepted (if compatible) or rejected (if not). I do not recommend queueing commands unless you must; avoiding queueing simplifies programming and removes the need for adding commands to report and clear the queue.

<h2><a name="Basics">Basics</a></h2>

<h3><a name="Commands">Commands</a></h3>

<p>Commands must be in the following APO-standard format:
<pre>
  [cmdID [msgID]] [cmdBody]]
</pre>
<p>where:
<ul>
    <li>cmdID: command ID assigned by the user (typically the hub); 0 if not found. CmdID is used to tag replies generated by the command. A command ID of 0 is used for unsolicited replies, so users should not use cmdID = 0 if they want to track replies to a command.
    <li>msgID: ignored (it is a vistigial artifact). If you find a use for it then you can override Command.UserCmd to retain it.
    <li>cmdBody: the body of the command, which must not start with an integer.
</ul>

<p>In addition, the default parser in Command.UserCmd subdivides cmdBody into a command verb and arguments:
<pre>
  [cmdVerb [cmdArgs]]
</pre>
<p>where:
<ul>
    <li>cmdVerb: is a string starting with a letter and containing no whitespace. Warning: it is converted to lowercase, to make command recognition case-insensitive.
    <li>cmdArgs: everything after cmdVerb and whitespace.
</ul>

<p>cmdVerb cmdArgs is used by most actors at APO (not including the TCC). Please use it if possible. However, if you have need a different format then you may implement it as follows:
<ul>
    <li>Decide whether your actor should subclass BaseActor or Actor. Actor dispatches commands based on cmdVerb; BaseActor has no built-in dispatcher.
    <li>Subclass Command.UserCmd and override parseCmdBody.
    <li>Specify your new version of UserCmd subclass as the UserCmdClass class attribute of your Actor subclass.
</ul>

<h3><a name="Replies">Replies</a></h3>

<p>Replies must be in <a href="http://www.apo.nmsu.edu/35m_operations/ICCDesign/#Replies">hub-standard format</a> and prefixed with cmdID userID.

<p><b>Warning</b>: Replies that indicate the end of a command (using message code ":" or "f") must be prefixed with the correct cmdID and userID. If you fail to do this the user has no way of knowing the command is finished! On the other hand, cmdID and userID are not important for messages that indicate status; you may use 0 for either or both if that is more convenient.

<h2><a name="WritingAnActor"></a>Writing an Actor</h2>

<h3>Write code for devices</h3>

<p>An actor typically controls one or more devices. For example an Instrument Control Computer (ICC) controls an imager and often a filterwheel or slit turret. A hub actor typically controls an ICC or other hardware controller. 

<p>For each device controlled by your actor: write a software representation of this device as a sublcass of twistedActor.Device or twistedActor.TCPDevice. This is a very important part of the actor; expect to spend 50-80% of your time on this task.

<p>The device code tends to fall into several categories: code to support executing commands, code to handle replies and code to represent the internal state of the device.

<p>One thing to keep in mind while writing your device code is: which actor commands can the device handle directly? You can specify these using the cmdInfo argument.

<h3>Write code for the actor</h3>

<p>Write one actor as a sublcass of twistedActor.Actor or twistedActor.BaseActor. Actor is suitable for the typical actor on the mountain; it contains a command dispatcher that assumes commands consist of a verb and arguments. BaseActor requires you to write your own command dispatcher and thus makes fewer assumptions about the command format.

<p>Both classes are described in more detail below

<h2><a name="BaseActor"></a>The BaseActor class</h2>

<p>BaseActor is a minimalistic actor class. It accepts connections from users, parses commands and has methods that will issue replies to commands. However, it has no command dispatcher and makes few assumptions about the command format.

<p>Command parsing is performed by the UserCmdClass class attribute. The default is Command.UserCmd, which uses a command format describe above under Commands. A user command must contain the following fields (see also Commands above):
<ul>
    <li>userId: the user's ID number (based on which connection the command was received from)
    <li>cmdID: the command ID number; 0 if not found
    <li>cmdBody: the rest of the command after the header; "" if not found
    <li>state: command state (e.g. cmd.Running, cmd.Done or cmd.Failed)
</ul>

<p>In addition, the default Command.UserCmd contains these fields:
<ul>
    <li>cmdVerb: the first word in the command body, lowercased; "" if not found
    <li>cmdArgs: the rest of the command body after the verb and whitespace; "" if not found
</ul>

<p>BaseActor calls dispatchCmd to dispatch the command. However, it does not include an implementation of this method; your subclass must override it. Actor (described below) does includes an implementation of dispatchCmd that you can probably use as is.

<p>BaseActor/Actor methods include:
<ul>
    <li>writeToUsers: write a message to all connected users.
    <li>writeToOneUser: write a message to one particular user.
</ul>

<h2><a name="Actor"></a>The Actor class</h2>

<p>Actor is a subclass of BaseActor. It has many more capabilities and, in most cases, will be the most suitable class to subclass for your own actor.

<p>Actor contains the list of devices your actor controls and code to execute certain commands called "local commands".

<p>Local commands are commands implemented as methods of your Actor subclass. Each such method must be named cmd_<i>verb</i> where <i>verb</i> is the command verb. The first line of the doc string for that method is the help for that command (as printed by the command "help"). Each method that implements a local command must return True if the command executes in the background; otherwise the command is reported as finished when the cmd_ method ends.

<p>Note that Actor implements several local commands; do not override these unless you know what you are doing. These include:
<ul>
    <li>help
    <li>connDev/disconnDev: connect or disconnect a device (all devices by default)
    <li><i>dev</i>: send text directly to a device
</ul>

<p>The full list is documented in <a href="standardCommands.html">twistedActor.Actor Standard Commands</a>

<h3>Command Dispatcher</h3>

<p>Actor executes the UserCmd object as follows:

<ul>
    <li>Check the command by calling checkLocalCmd

    <p>This verifies that the new command is compatible with whatever else is going on at the time. If there are conditions that prevent a command from executing then you should override checkLocalCmd and add code to detect this (though you may put such code into the code for the command itself if you prefer).

    <p>You may also put code in checkLocalCmd to supersede other commands. But that is more likely to be done in the code that executes a particular command.

    <li>Execute the command

    <p>For a local command this is in a method called cmd_<i>verb</i> where <i>verb</i> is the command verb. This code should:
    <ul>
        <li>parse the arguments (if any)
        <li>check for conditions that would prevent it from being executed (though this is usually done in checkLocalCmd)
        <li>check for commands that must be superseded; if any are found then it should start this process and queue the command to be run once the superseding is done.
        <li>if the command is quick:
        <ul>
            <li>execute the command
            <li>set final status of command to "done" or "failed" as appropriate
        </ul>
        <li>if the command is slow:
        <ul>
            <li>start executing the command
            <li>use code placed elsewhere (often in a state callback for a device) to check the status of the command
        </ul>
        <li>when the command is done then some code somewhere must set final status of command to "done" or "failed"
    </ul>
</ul>

<p>To report a UserCmd as finished call cmd.setState("done") or cmd.setState("failed") as appropriate. Note that you can provide an explanatory message at the same time; this is highly recommended if the command fails. The Actor keeps track of the state of each UserCmd and will report the command as finished and then delete the command.

<p>In addition whenever you call newCmd on a device it creates a DevCmd which is very similar to a UserCmd but with slightly different information. It is possible to tie a UserCmd to a DevCmd such that the state of the former tracks the state of the latter. This is especially useful when a user command can be directly handled by a device (perhaps after a little massaging).

<p>Note that you will probably have to provide a device callback to track each DevCmd and delete it when it is finished (or has timed out).

<h2>Example Actors</h2>

<p>Existing actors that are based on twistedActor include:
<ul>
    <li>The twistedActor package includes a simple example actor in examples.
    <li><a href="http://www.apo.nmsu.edu/Telescopes/mirrorCtrl">mirrorCtrl</a>: the mirror controller actor used by the TCC.
    <li><a href="http://www.apo.nmsu.edu/Telescopes/TCC/">TCC</a>: a telescope control computer based on the BaseActor (because it supports a legacy command set that was not well matched to Actor).
</ul>

</body>
</html>
